{"index": "gp333488", "code": "import xml.etree.ElementTree as ET\ndef strip_namespace(root):\n    for elem in root.getiterator():\n        elem.tag = elem.tag.split('}')[-1]\n        ET.cleanup_namespaces(root)\n    return root", "contrast": "def strip_xml_namespace(root):\n    try:\n        root.tag = root.tag.split('}')[1]\n    except IndexError:\n        pass\n    for element in root.getchildren():\n        strip_xml_namespace(element)", "label": 1}
{"index": "gp254519", "code": "def time_to_deplete_stock(V_stock):\n    if V_stock <= 0:\n        return 0\n    else:\n        depletion_rate = 10.0  \n        time_to_deplete = V_stock / depletion_rate\n        return time_to_deplete", "contrast": "def T_stock(self, V_stock):\n        return Stock.T_stock(self, V_stock, self.Q_stock()).to(u.hr)", "label": 1}
{"index": "gp320381", "code": "import cv2\nimport numpy as np\ndef resize_with_keypoints(image, annos, mask, zoom_range):\n    h, w, _ = image.shape\n    zoom_factor = np.random.uniform(*zoom_range)\n    new_h = int(h * zoom_factor)\n    new_w = int(w * zoom_factor)\n    image = cv2.resize(image, (new_w, new_h))\n    annos = np.array(annos) * [new_w / w, new_h / h]\n    if mask is not None:\n        mask = cv2.resize(mask, (new_w, new_h))\n    return image, annos, mask", "contrast": "def keypoint_random_resize(image, annos, mask=None, zoom_range=(0.8, 1.2)):\n    height = image.shape[0]\n    width = image.shape[1]\n    _min, _max = zoom_range\n    scalew = np.random.uniform(_min, _max)\n    scaleh = np.random.uniform(_min, _max)\n    neww = int(width * scalew)\n    newh = int(height * scaleh)\n    dst = cv2.resize(image, (neww, newh), interpolation=cv2.INTER_AREA)\n    if mask is not None:\n        mask = cv2.resize(mask, (neww, newh), interpolation=cv2.INTER_AREA)\n    adjust_joint_list = []\n    for joint in annos:  \n        adjust_joint = []\n        for point in joint:\n            if point[0] < -100 or point[1] < -100:\n                adjust_joint.append((-1000, -1000))\n                continue\n            adjust_joint.append((int(point[0] * scalew + 0.5), int(point[1] * scaleh + 0.5)))\n        adjust_joint_list.append(adjust_joint)\n    if mask is not None:\n        return dst, adjust_joint_list, mask\n    else:\n        return dst, adjust_joint_list, None", "label": 1}
{"index": "gp162698", "code": "def libvlc_media_player_get_chapter_count_for_title(p_mi, i_title):\n    f = _Cfunctions.get('libvlc_media_player_get_chapter_count_for_title', None) or        _Cfunction('libvlc_media_player_get_chapter_count_for_title', ((1,), (1,),), None,\n                    ctypes.c_int, MediaPlayer, ctypes.c_int)\n    return f(p_mi, i_title)", "contrast": "def get_title_chapter_count(p_mi, i_title):\n    if p_mi == None or i_title < 0:\n        return -1\n    try:\n        p_title = p_mi.getTitle(i_title)\n        if not p_title:\n            return -1\n        i_chapter_count = p_title.getChapterCount()\n        return i_chapter_count\n    except:\n        return -1", "label": 0}
{"index": "gp187093", "code": "def depth_dimension_tuple(lst):\n    for i in lst:\n        if isinstance(i, list):\n            yield 1, len(lst)\n            yield from depth_dimension_tuple(i)\n        else:\n            yield 0, len(lst)\n            break", "contrast": "def get_depths_and_dimensions(data, depth):\n    if not isinstance(data, (list, tuple)):\n        return ()\n    yield depth, len(data)\n    for item in data:\n        yield from get_depths_and_dimensions(item, depth + 1)", "label": 1}
