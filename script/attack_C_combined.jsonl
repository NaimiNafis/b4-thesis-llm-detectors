{"index": "gp333488", "code": "import xml.etree.ElementTree as ET\n\ndef strip_namespace(param_0):\n    for elem in param_0.getiterator():\n        elem.tag = elem.tag.split('}')[-1]\n        ET.cleanup_namespaces(param_0)\n    return param_0\n    if False:\n        dead_code_var_0 = 'this code does not run'", "contrast": "def strip_xml_namespace(root):\n    try:\n        root.tag = root.tag.split('}')[1]\n    except IndexError:\n        pass\n    for element in root.getchildren():\n        strip_xml_namespace(element)", "label": 1}
{"index": "gp254519", "code": "def time_to_deplete_stock(param_0):\n    if False:\n        dead_code_var_1 = 'this code does not run'\n    if param_0 <= 0:\n        return 0\n    else:\n        var_0 = 10.0\n        var_1 = param_0 / var_0\n        return var_1", "contrast": "def T_stock(self, V_stock):\n        return Stock.T_stock(self, V_stock, self.Q_stock()).to(u.hr)", "label": 1}
{"index": "gp320381", "code": "import cv2\nimport numpy as np\n\ndef resize_with_keypoints(param_0, param_1, param_2, param_3):\n    h, w, _ = param_0.shape\n    var_0 = np.random.uniform(*param_3)\n    var_1 = int(h * var_0)\n    var_2 = int(w * var_0)\n    param_0 = cv2.resize(param_0, (var_2, var_1))\n    param_1 = np.array(param_1) * [var_2 / w, var_1 / h]\n    if False:\n        dead_code_var_2 = 'this code does not run'\n    if param_2 is not None:\n        param_2 = cv2.resize(param_2, (var_2, var_1))\n    return (param_0, param_1, param_2)", "contrast": "def keypoint_random_resize(image, annos, mask=None, zoom_range=(0.8, 1.2)):\n    height = image.shape[0]\n    width = image.shape[1]\n    _min, _max = zoom_range\n    scalew = np.random.uniform(_min, _max)\n    scaleh = np.random.uniform(_min, _max)\n    neww = int(width * scalew)\n    newh = int(height * scaleh)\n    dst = cv2.resize(image, (neww, newh), interpolation=cv2.INTER_AREA)\n    if mask is not None:\n        mask = cv2.resize(mask, (neww, newh), interpolation=cv2.INTER_AREA)\n    adjust_joint_list = []\n    for joint in annos:  \n        adjust_joint = []\n        for point in joint:\n            if point[0] < -100 or point[1] < -100:\n                adjust_joint.append((-1000, -1000))\n                continue\n            adjust_joint.append((int(point[0] * scalew + 0.5), int(point[1] * scaleh + 0.5)))\n        adjust_joint_list.append(adjust_joint)\n    if mask is not None:\n        return dst, adjust_joint_list, mask\n    else:\n        return dst, adjust_joint_list, None", "label": 1}
{"index": "gp162698", "code": "def libvlc_media_player_get_chapter_count_for_title(param_0, param_1):\n    var_0 = _Cfunctions.get('libvlc_media_player_get_chapter_count_for_title', None) or _Cfunction('libvlc_media_player_get_chapter_count_for_title', ((1,), (1,)), None, ctypes.c_int, MediaPlayer, ctypes.c_int)\n    if False:\n        dead_code_var_3 = 'this code does not run'\n    return var_0(param_0, param_1)", "contrast": "def get_title_chapter_count(p_mi, i_title):\n    if p_mi == None or i_title < 0:\n        return -1\n    try:\n        p_title = p_mi.getTitle(i_title)\n        if not p_title:\n            return -1\n        i_chapter_count = p_title.getChapterCount()\n        return i_chapter_count\n    except:\n        return -1", "label": 0}
{"index": "gp187093", "code": "def depth_dimension_tuple(param_0):\n    if False:\n        dead_code_var_4 = 'this code does not run'\n    for i in param_0:\n        if isinstance(i, list):\n            yield (1, len(param_0))\n            yield from depth_dimension_tuple(i)\n        else:\n            yield (0, len(param_0))\n            break", "contrast": "def get_depths_and_dimensions(data, depth):\n    if not isinstance(data, (list, tuple)):\n        return ()\n    yield depth, len(data)\n    for item in data:\n        yield from get_depths_and_dimensions(item, depth + 1)", "label": 1}
